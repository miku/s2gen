// s2gen takes as input a SOLR schema.xml and outputs structs and methods to
// access documents conforming to that schema.
package main

import (
	"bytes"
	"crypto/sha1"
	"encoding/xml"
	"flag"
	"fmt"
	"go/format"
	"io"
	"os"
	"os/user"
	"strings"
	"text/template"
	"time"

	ssg "github.com/miku/s2gen"
	log "github.com/sirupsen/logrus"
)

const Version = "0.1.0"

var (
	skipFormatting   = flag.Bool("F", false, "skip formatting")
	showVersion      = flag.Bool("version", false, "show version")
	useHashSuffix    = flag.Bool("hs", false, "add part of hash as suffix to struct name")
	useVersionSuffix = flag.String("vs", "", "add some versioning suffix, like v0 to struct name")
)

// field contains information about static fields.
type field struct {
	GoName string
	GoType string
	GoTag  string
}

// dynamicField contains basic information on a dynamic field
type dynamicField struct {
	Name          string
	IsMultiValued string
}

// payload provides data for template.
type payload struct {
	Name          string
	VarName       string
	Digest        string
	Date          string
	User          string
	Host          string
	Version       string
	Fields        []field
	DynamicFields []dynamicField
}

func main() {
	flag.Parse()
	if *showVersion {
		fmt.Println(Version)
		os.Exit(0)
	}

	var r io.Reader = os.Stdin

	if flag.NArg() > 0 {
		f, err := os.Open(flag.Arg(0))
		if err != nil {
			log.Fatal(err)
		}
		defer f.Close()
		r = f
	}

	h := sha1.New()
	tee := io.TeeReader(r, h)

	dec := xml.NewDecoder(tee)
	dec.Strict = false

	var schema ssg.Schema
	if err := dec.Decode(&schema); err != nil {
		log.Fatal(err)
	}

	digest := fmt.Sprintf("%x", h.Sum(nil))

	// Fix name of type and variable name.
	name := ssg.GoName(schema.Name)
	if name == "" {
		log.Fatal("the go name reduced to the empty string")
	}
	varName := strings.ToLower(name[0:1])

	// Optional suffixes.
	if *useHashSuffix {
		name = name + digest[0:8]
	}
	if *useVersionSuffix != "" {
		name = name + *useVersionSuffix
	}

	// Some metadata.
	usrName := "an unknown user"
	usr, _ := user.Current()
	if usr != nil {
		usrName = usr.Username
	}
	hostname, err := os.Hostname()
	if err != nil {
		hostname = "an unknown host"
	}

	// Payload for template.
	data := payload{
		Name:    name,
		VarName: varName,
		Digest:  digest,
		Date:    time.Now().Format(time.RFC3339),
		User:    usrName,
		Host:    hostname,
		Version: Version,
	}

	for _, f := range schema.Fields.Field {
		ff := field{
			GoName: ssg.GoName(f.Name),
			GoTag:  fmt.Sprintf("`json:\"%s\"`", f.Name),
		}
		switch {
		case f.Name == "_version_":
			ff.GoType = "json.Number"
		case f.MultiValued == "true":
			ff.GoType = "[]string"
		default:
			ff.GoType = "string"
		}
		data.Fields = append(data.Fields, ff)
	}

	for _, f := range schema.Fields.DynamicField {
		if f.MultiValued == "" {
			f.MultiValued = "false"
		}
		ff := dynamicField{Name: f.Name, IsMultiValued: f.MultiValued}
		data.DynamicFields = append(data.DynamicFields, ff)
	}

	// Render template.
	t, err := template.New("document.tmpl").Parse(documentTemplate)
	if err != nil {
		log.Fatal(err)
	}
	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		log.Fatal(err)
	}

	// Format output.
	if *skipFormatting {
		fmt.Println(buf.String())
	} else {
		b, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatal(err)
		}
		fmt.Println(string(b))
	}
}

// template from tmpl/document.tmpl.
var documentTemplate = `
// Autogenerated by s2gen {{ .Version }} on {{ .Date }} by {{ .User }} on {{ .Host }}.
// Schema SHA1 was {{ .Digest }}.
// Do NOT modify, unless you know what you do.
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"

    "github.com/fatih/structs"
)

// {{ .Name }} generated from schema.
// This struct supports marshaling and unmarshaling of SOLR documents conforming to the
// schema that was used to generate this struct. Static fields are struct fields, dynamic
// fields can be modified by using {{ .VarName }}.Field("dyn_*").Set(...) and so on.
type {{ .Name }} struct {
	{{ range .Fields }}
		{{ .GoName }} {{ .GoType }} {{ .GoTag -}}
	{{ end }}

    fields []*dynamicField
}

// New{{ .Name }} creates a new document conforming to a schema for the dynamic fields.
func New{{ .Name }}() *{{ .Name }} {
	return &{{ .Name }}{
		fields: []*dynamicField{
			{{ range .DynamicFields -}}
			&dynamicField{name: "{{ .Name }}", isMultiValued: {{ .IsMultiValued }}},
			{{ end }}
		},
	}
}


// MarshalJSON serialized static and dynamic fields.
func ({{ .VarName }} *{{ .Name }}) MarshalJSON() ([]byte, error) {
	temp := structs.Map({{ .VarName }})
	for _, field := range {{ .VarName }}.fields {
		for key, value := range field.fmap {
			temp[key] = value
		}
	}
	return json.Marshal(temp)
}

// UnmarshalJSON unmarshals a document. It is not an error, if there are
// fields, which do not fit neither into static of dynamic definitions.
func ({{ .VarName }} *{{ .Name }}) UnmarshalJSON(pp []byte) error {
	temp := make(map[string]interface{})
	if err := json.Unmarshal(pp, &temp); err != nil {
		return err
	}
	st := structs.New({{ .VarName }})
	for _, field := range st.Fields() {
		name := field.Tag("json")
		if name == "" {
			name = field.Name()
		}
		if value, ok := temp[name]; ok {
			switch tv := value.(type) {
			case float64, string, []string:
				field.Set(tv)
			case []interface{}:
				field.Set(toStringSlice(tv))
			default:
				return fmt.Errorf("cannot set value for type %T", tv)
			}
		}
	}
	for _, field := range {{ .VarName }}.fields {
		for key, value := range temp {
			if err := field.isCompatible(key); err != nil {
				continue
			}
			if err := field.Set(key, value); err != nil {
				return err
			}
		}
	}
	return nil
}

// DynamicFieldnames returns the dynamic field wildcards.
func ({{ .VarName }} *{{ .Name }}) DynamicFieldnames() (names []string) {
    for _, f := range {{ .VarName }}.fields {
        names = append(names, f.name)
    }
    return
}

// DynamicFields returns a map of concrete fields for a given wildcard.
func ({{ .VarName }} *{{ .Name }}) DynamicFields(name string) (map[string][]string, error) {
    for _, f := range {{ .VarName }}.fields {
        if f.name == name {
            return f.fmap, nil
        }
    }
    return nil, fmt.Errorf("no such field: %s", name)
}

// toStringSlice returns a slice of strings
func toStringSlice(is []interface{}) (values []string) {
	for _, v := range is {
		values = append(values, fmt.Sprintf("%s", v))
	}
	return
}


// dynamicField represents a more generic multi-valued field.
type dynamicField struct {
	name          string
	isMultiValued bool
	fmap          map[string][]string
}

// ensureMap lazily initializes the map.
func (f *dynamicField) ensureMap() {
        if f.fmap == nil {
                f.fmap = make(map[string][]string)
        }
}

// isCompatible returns nil, if the given key string can be used for this
// dynamic field.
func (f *dynamicField) isCompatible(key string) error {
	re, err := regexp.Compile("^" + strings.Replace(f.name, "*", ".*", -1) + "$")
	if err != nil {
			return err
	}
	if re.MatchString(key) {
			return nil
	}
	return fmt.Errorf("incompatible key")
}

// addStrings tries to add a list of strings to the given key k
func (f *dynamicField) addStrings(k string, ss []string) error {
	f.ensureMap()
	switch f.isMultiValued {
	case true:
		f.fmap[k] = append(f.fmap[k], ss...)
	case false:
		if _, ok := f.fmap[k]; ok {
				return fmt.Errorf("single-valued field %s exists", f.name)
		}
		if len(ss) > 1 {
				return fmt.Errorf("multiple values for single-valued field %s", f.name)
		}
		f.fmap[k] = ss
	}
	return nil
}

// setStrings tries to set a list of strings to the given key k
func (f *dynamicField) setStrings(k string, ss []string) error {
	f.ensureMap()
	switch f.isMultiValued {
	case true:
			f.fmap[k] = ss
	case false:
			if len(ss) > 1 {
					return fmt.Errorf("multiple values for single-valued field %s", f.name)
			}
			f.fmap[k] = ss
	}
	return nil
}


// Clear remove all values for a key.
func (f *dynamicField) Clear(k string) {
	f.ensureMap()
	if _, ok := f.fmap[k]; ok {
		delete(f.fmap, k)
	}
}

// Add value or values to a given field. It is an error if a single valued
// field would have more than one element.
func (f *dynamicField) Add(k string, v interface{}) (err error) {
	f.ensureMap()
	if err = f.isCompatible(k); err != nil {
		return
	}
	switch t := v.(type) {
	case string:
		err = f.addStrings(k, []string{t})
	case []string:
		err = f.addStrings(k, t)
	case []interface{}:
		err = f.addStrings(k, toStringSlice(t))
	default:
		err = fmt.Errorf("type %T for values not supported", v)
	}
	return
}

// Set sets the values for a given key. It accepts a single string or a string
// slice. If is an error, if a string slice is used for a single valued field.
func (f *dynamicField) Set(k string, v interface{}) (err error) {
	f.ensureMap()
	if err = f.isCompatible(k); err != nil {
		return
	}
	switch t := v.(type) {
	case string:
		f.fmap[k] = []string{t}
	case []string:
		err = f.setStrings(k, t)
	case []interface{}:
		err = f.setStrings(k, toStringSlice(t))
	default:
		err = fmt.Errorf("type %T for values not supported", v)
	}
	return
}

// Value returns a single value for a key and whether the key was actually present.
func (f *dynamicField) Value(key string) (value string, ok bool) {
	f.ensureMap()
	var vs []string
	vs, ok = f.fmap[key]
	if !ok || len(vs) == 0 {
		return
	}
	return vs[0], true
}

// Values returns multiple values for a key and whether the key was actually present.
func (f *dynamicField) Values(key string) (values []string, ok bool) {
	f.ensureMap()
	values, ok = f.fmap[key]
	if !ok {
		return
	}
	return values, true
}

func main() {
	dec := json.NewDecoder(os.Stdin)
	doc := New{{ .Name }}()

	if err := dec.Decode(&doc); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("%+v", doc)
}
`
