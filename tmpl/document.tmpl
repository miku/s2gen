// Autogenerated by s2gen {{ .Version }} on {{ .Date }} by {{ .User }} on {{ .Host }}.
// Schema SHA1 was {{ .Digest }}.
// Do NOT modify, unless you know what you do.
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"

    "github.com/fatih/structs"
)

// {{ .Name }} generated from schema.
// This struct supports marshaling and unmarshaling of SOLR documents conforming to the
// schema that was used to generate this struct. Static fields are struct fields, dynamic
// fields can be modified by using {{ .VarName }}.Field("dyn_*").Set(...) and so on.
type {{ .Name }} struct {
	{{ range .Fields }}
		{{ .GoName }} {{ .GoType }} {{ .GoTag -}}
	{{ end }}

    fields []*dynamicField
}

// New{{ .Name }} creates a new document conforming to a schema for the dynamic fields.
func New{{ .Name }}() *{{ .Name }} {
    var {{ .VarName }} {{ .Name }}
    {{ .VarName }}.initDynamicFields()
    return &{{ .VarName }}
}

// initDynamicFields will initialize or reset the dynamic fields.
func ({{ .VarName }} *{{ .Name }}) initDynamicFields() {
    {{ .VarName }}.fields = []*dynamicField{
		{{ range .DynamicFields -}}
		&dynamicField{name: "{{ .Name }}", isMultiValued: {{ .IsMultiValued }}},
		{{ end }}
    }
}

// MarshalJSON serialized static and dynamic fields.
func ({{ .VarName }} *{{ .Name }}) MarshalJSON() ([]byte, error) {
	temp := structs.Map({{ .VarName }})
	for _, field := range {{ .VarName }}.fields {
		for key, value := range field.fmap {
			temp[key] = value
		}
	}
	return json.Marshal(temp)
}

// UnmarshalJSON unmarshals a document. It is not an error, if there are
// fields, which do not fit neither into static of dynamic definitions.
// As unmarshaling can happen in larger structs, a new value is created.
func ({{ .VarName }} *{{ .Name }}) UnmarshalJSON(pp []byte) error {
    {{ .VarName }}.initDynamicFields()
	temp := make(map[string]interface{})
	if err := json.Unmarshal(pp, &temp); err != nil {
		return err
	}
	st := structs.New({{ .VarName }})
	for _, field := range st.Fields() {
		name := field.Tag("json")
		if name == "" {
			name = field.Name()
		}
		if value, ok := temp[name]; ok {
			switch tv := value.(type) {
			case float64, string, []string:
				field.Set(tv)
			case []interface{}:
				field.Set(toStringSlice(tv))
			default:
				return fmt.Errorf("cannot set value for type %T", tv)
			}
		}
	}
	for _, field := range {{ .VarName }}.fields {
		for key, value := range temp {
			if err := field.isCompatible(key); err != nil {
				continue
			}
			if err := field.Set(key, value); err != nil {
				return err
			}
		}
	}
	return nil
}

// DynamicFieldnames returns the dynamic field wildcards.
func ({{ .VarName }} *{{ .Name }}) DynamicFieldnames() (names []string) {
    for _, f := range {{ .VarName }}.fields {
        names = append(names, f.name)
    }
    return
}

// DynamicFields returns a map of concrete fields for a given wildcard.
func ({{ .VarName }} *{{ .Name }}) DynamicFields(name string) (map[string][]string, error) {
    for _, f := range {{ .VarName }}.fields {
        if f.name == name {
            return f.fmap, nil
        }
    }
    return nil, fmt.Errorf("no such field: %s", name)
}

// Field returns the dynamic field with a given name. It is an error,
// if the field does not exist.
func ({{ .VarName }} *{{ .Name }}) Field(name string) (*dynamicField, error) {
    for _, field := range {{ .VarName }}.fields {
		if field.name == name {
			return field, nil
		}
	}
	return nil, fmt.Errorf("no such field: %s", name)
}

// MustField returns the field or nil.
func ({{ .VarName }} *{{ .Name }}) MustField(name string) *dynamicField {
	field, _ := v.Field(name)
	return field
}

// toStringSlice returns a slice of strings
func toStringSlice(is []interface{}) (values []string) {
	for _, v := range is {
		values = append(values, fmt.Sprintf("%s", v))
	}
	return
}


// dynamicField represents a more generic multi-valued field.
type dynamicField struct {
	name          string
	isMultiValued bool
	fmap          map[string][]string
}

// ensureMap lazily initializes the map.
func (f *dynamicField) ensureMap() {
        if f.fmap == nil {
                f.fmap = make(map[string][]string)
        }
}

// isCompatible returns nil, if the given key string can be used for this
// dynamic field.
func (f *dynamicField) isCompatible(key string) error {
	re, err := regexp.Compile("^" + strings.Replace(f.name, "*", ".*", -1) + "$")
	if err != nil {
			return err
	}
	if re.MatchString(key) {
			return nil
	}
	return fmt.Errorf("incompatible key")
}

// addStrings tries to add a list of strings to the given key k
func (f *dynamicField) addStrings(k string, ss []string) error {
	f.ensureMap()
	switch f.isMultiValued {
	case true:
		f.fmap[k] = append(f.fmap[k], ss...)
	case false:
		if _, ok := f.fmap[k]; ok {
				return fmt.Errorf("single-valued field %s exists", f.name)
		}
		if len(ss) > 1 {
				return fmt.Errorf("multiple values for single-valued field %s", f.name)
		}
		f.fmap[k] = ss
	}
	return nil
}

// setStrings tries to set a list of strings to the given key k
func (f *dynamicField) setStrings(k string, ss []string) error {
	f.ensureMap()
	switch f.isMultiValued {
	case true:
			f.fmap[k] = ss
	case false:
			if len(ss) > 1 {
					return fmt.Errorf("multiple values for single-valued field %s", f.name)
			}
			f.fmap[k] = ss
	}
	return nil
}


// Clear remove all values for a key.
func (f *dynamicField) Clear(k string) {
	f.ensureMap()
	if _, ok := f.fmap[k]; ok {
		delete(f.fmap, k)
	}
}

// Add value or values to a given field. It is an error if a single valued
// field would have more than one element.
func (f *dynamicField) Add(k string, v interface{}) (err error) {
	f.ensureMap()
	if err = f.isCompatible(k); err != nil {
		return
	}
	switch t := v.(type) {
	case string:
		err = f.addStrings(k, []string{t})
	case []string:
		err = f.addStrings(k, t)
	case []interface{}:
		err = f.addStrings(k, toStringSlice(t))
	default:
		err = fmt.Errorf("type %T for values not supported", v)
	}
	return
}

// Set sets the values for a given key. It accepts a single string or a string
// slice. If is an error, if a string slice is used for a single valued field.
func (f *dynamicField) Set(k string, v interface{}) (err error) {
	f.ensureMap()
	if err = f.isCompatible(k); err != nil {
		return
	}
	switch t := v.(type) {
	case string:
		f.fmap[k] = []string{t}
	case []string:
		err = f.setStrings(k, t)
	case []interface{}:
		err = f.setStrings(k, toStringSlice(t))
	default:
		err = fmt.Errorf("type %T for values not supported", v)
	}
	return
}

// Value returns a single value for a key and whether the key was actually present.
func (f *dynamicField) Value(key string) (value string, ok bool) {
	f.ensureMap()
	var vs []string
	vs, ok = f.fmap[key]
	if !ok || len(vs) == 0 {
		return
	}
	return vs[0], true
}

// Values returns multiple values for a key and whether the key was actually present.
func (f *dynamicField) Values(key string) (values []string, ok bool) {
	f.ensureMap()
	values, ok = f.fmap[key]
	if !ok {
		return
	}
	return values, true
}

// MustValue returns the value or an empty string.
func (f *dynamicField) MustValue(key string) string {
    value, _ := f.Value(key)
    return value
}

// MustValues returns slice of values of a nil slice.
func (f *dynamicField) MustValues(key string) []string {
    values, _ := f.Values(key)
    return values
}

func main() {
	dec := json.NewDecoder(os.Stdin)
	var doc {{ .Name }}

	if err := dec.Decode(&doc); err != nil {
		log.Fatal(err)
	}

	fmt.Printf("%+v", doc)
}

