# s2gen (solr struct generator)

Generate code to represent [SOLR](http://lucene.apache.org/solr/) documents in Go from a schema.xml file.

## Install

```shell
$ go get github.com/miku/s2gen/cmd/s2gen
```

This is experimental software.

## About

Solr allows to specify a
[schema](https://lucene.apache.org/solr/guide/6_6/documents-fields-and-schema-design.html),
consisting of fields, types, cardinality and dynamic types. To facilitate the
creation of documents conforming to a SOLR schema, it would be nice, to
generate a struct and code for a schema automatically from the XML schema definition.

The SOLR schema is documented at [Documents, Fields, and Schema
Design](https://lucene.apache.org/solr/guide/6_6/documents-fields-and-schema-design.html).

The following features are implemented:

* generating a struct from a SOLR schema.xml
* marshal an indexable JSON document from that struct
* unmarshal SOLR documents into a struct including dynamic fields
* static and dynamic fields with cardinality checks

Not supported or low priority:

* type inference (to many variations, so we only use strings for now)

## Example SOLR schema

* Taken from a VuFind project (see also: [schema.xml](https://github.com/vufind-org/vufind/blob/master/solr/vufind/biblio/conf/schema.xml)).

```xml
<schema name="VuFind Bibliographic Index" version="1.2">
  ...
  <fields>
    <!-- Required by Solr 4.x -->
    <field name="_version_" type="long" indexed="true" stored="true"/>
    <!-- Core Fields  -->
    <field name="id" type="string" indexed="true" stored="true"/>
    <field name="fullrecord" type="string" indexed="false" stored="true"/>
    ...
    <!-- Dynamic fields for customization without schema modification -->
    <dynamicField name="callnumber_*" type="code" indexed="true" stored="true" multiValued="true"/>
    <dynamicField name="barcode_*" type="code" indexed="true" stored="true" multiValued="true"/>
    <dynamicField name="misc_*" type="textFacet" indexed="true" stored="true" multiValued="true"/>
  </fields>
  <!-- Default Boolean Operator -->
  <solrQueryParser defaultOperator="AND"/>
  ...
</schema>
```

## Usage

First, generate the code from the SOLR schema.

```shell
$ s2gen < schema.xml > example.go
```

As an example, let say this generated a struct named `VuFindBibliographicIndex`
and a few helper functions. From here, you have various ways to populate the
struct values.

```go
doc := NewVuFindBibliographicIndex()

// Manipulate static fields, multi-valued fields are slices.
doc.Fulltext = "This is the full text"
doc.Author = append(doc.Author, "Samuel Johnson")

// Set a single dynamic field. Error, if dynamic field is not valid.
err := doc.Set("format_de15", "Book")

// Create an indexable document.
b, _ := json.Marshal(doc)
fmt.Println(string(b))
```

## Use case


* writing converters
* linter for solr documents
* generic SOLR documents manipulation: fetch, unmarshal, modify, marshal, index.

## Example

```go
$ curl -sL https://git.io/fxhhz | s2gen
// Autogenerated by s2gen {{ .Version }} on {{ .Date }} by {{ .User }} on {{ .Host }}.
// Schema SHA1 was {{ .Digest }}.
// Do NOT modify, unless you know what you do.
package main

import (
    "encoding/json"
    "fmt"
    "log"
    "os"
    "regexp"
    "strings"

    "github.com/fatih/structs"
)

// {{ .Name }} generated from schema.
// This struct supports marshaling and unmarshaling of SOLR documents conforming to the
// schema that was used to generate this struct. Static fields are struct fields, dynamic
// fields can be modified by using {{ .VarName }}.Field("dyn_*").Set(...) and so on.
type {{ .Name }} struct {
    {{ range .Fields }}
        {{ .GoName }} {{ .GoType }} {{ .GoTag -}}
    {{ end }}

    fields []*dynamicField
}

// New{{ .Name }} creates a new document conforming to a schema for the dynamic fields.
func New{{ .Name }}() *{{ .Name }} {
    return &{{ .Name }}{
        fields: []*dynamicField{
            {{ range .DynamicFields -}}
            &dynamicField{name: "{{ .Name }}", isMultiValued: {{ .IsMultiValued }}},
            {{ end }}
        },
    }
}


// MarshalJSON serialized static and dynamic fields.
func ({{ .VarName }} *{{ .Name }}) MarshalJSON() ([]byte, error) {
    temp := structs.Map({{ .VarName }})
    for _, field := range {{ .VarName }}.fields {
        for key, value := range field.fmap {
            temp[key] = value
        }
    }
    return json.Marshal(temp)
}

// UnmarshalJSON unmarshals a document. It is not an error, if there are
// fields, which do not fit neither into static of dynamic definitions.
func ({{ .VarName }} *{{ .Name }}) UnmarshalJSON(pp []byte) error {
    temp := make(map[string]interface{})
    if err := json.Unmarshal(pp, &temp); err != nil {
        return err
    }
    st := structs.New({{ .VarName }})
    for _, field := range st.Fields() {
        name := field.Tag("json")
        if name == "" {
            name = field.Name()
        }
        if value, ok := temp[name]; ok {
            switch tv := value.(type) {
            case float64, string, []string:
                field.Set(tv)
            case []interface{}:
                field.Set(toStringSlice(tv))
            default:
                return fmt.Errorf("cannot set value for type %T", tv)
            }
        }
    }
    for _, field := range {{ .VarName }}.fields {
        for key, value := range temp {
            if err := field.isCompatible(key); err != nil {
                continue
            }
            if err := field.Set(key, value); err != nil {
                return err
            }
        }
    }
    return nil
}

// DynamicFieldnames returns the dynamic field wildcards.
func ({{ .VarName }} *{{ .Name }}) DynamicFieldnames() (names []string) {
    for _, f := range {{ .VarName }}.fields {
        names = append(names, f.name)
    }
    return
}

// DynamicFields returns a map of concrete fields for a given wildcard.
func ({{ .VarName }} *{{ .Name }}) DynamicFields(name string) (map[string][]string, error) {
    for _, f := range {{ .VarName }}.fields {
        if f.name == name {
            return f.fmap, nil
        }
    }
    return nil, fmt.Errorf("no such field: %s", name)
}

// toStringSlice returns a slice of strings
func toStringSlice(is []interface{}) (values []string) {
    for _, v := range is {
        values = append(values, fmt.Sprintf("%s", v))
    }
    return
}


// dynamicField represents a more generic multi-valued field.
type dynamicField struct {
    name          string
    isMultiValued bool
    fmap          map[string][]string
}

// ensureMap lazily initializes the map.
func (f *dynamicField) ensureMap() {
        if f.fmap == nil {
                f.fmap = make(map[string][]string)
        }
}

// isCompatible returns nil, if the given key string can be used for this
// dynamic field.
func (f *dynamicField) isCompatible(key string) error {
    re, err := regexp.Compile("^" + strings.Replace(f.name, "*", ".*", -1) + "$")
    if err != nil {
            return err
    }
    if re.MatchString(key) {
            return nil
    }
    return fmt.Errorf("incompatible key")
}

// addStrings tries to add a list of strings to the given key k
func (f *dynamicField) addStrings(k string, ss []string) error {
    f.ensureMap()
    switch f.isMultiValued {
    case true:
        f.fmap[k] = append(f.fmap[k], ss...)
    case false:
        if _, ok := f.fmap[k]; ok {
                return fmt.Errorf("single-valued field %s exists", f.name)
        }
        if len(ss) > 1 {
                return fmt.Errorf("multiple values for single-valued field %s", f.name)
        }
        f.fmap[k] = ss
    }
    return nil
}

// setStrings tries to set a list of strings to the given key k
func (f *dynamicField) setStrings(k string, ss []string) error {
    f.ensureMap()
    switch f.isMultiValued {
    case true:
            f.fmap[k] = ss
    case false:
            if len(ss) > 1 {
                    return fmt.Errorf("multiple values for single-valued field %s", f.name)
            }
            f.fmap[k] = ss
    }
    return nil
}


// Clear remove all values for a key.
func (f *dynamicField) Clear(k string) {
    f.ensureMap()
    if _, ok := f.fmap[k]; ok {
        delete(f.fmap, k)
    }
}

// Add value or values to a given field. It is an error if a single valued
// field would have more than one element.
func (f *dynamicField) Add(k string, v interface{}) (err error) {
    f.ensureMap()
    if err = f.isCompatible(k); err != nil {
        return
    }
    switch t := v.(type) {
    case string:
        err = f.addStrings(k, []string{t})
    case []string:
        err = f.addStrings(k, t)
    case []interface{}:
        err = f.addStrings(k, toStringSlice(t))
    default:
        err = fmt.Errorf("type %T for values not supported", v)
    }
    return
}

// Set sets the values for a given key. It accepts a single string or a string
// slice. If is an error, if a string slice is used for a single valued field.
func (f *dynamicField) Set(k string, v interface{}) (err error) {
    f.ensureMap()
    if err = f.isCompatible(k); err != nil {
        return
    }
    switch t := v.(type) {
    case string:
        f.fmap[k] = []string{t}
    case []string:
        err = f.setStrings(k, t)
    case []interface{}:
        err = f.setStrings(k, toStringSlice(t))
    default:
        err = fmt.Errorf("type %T for values not supported", v)
    }
    return
}

// Value returns a single value for a key and whether the key was actually present.
func (f *dynamicField) Value(key string) (value string, ok bool) {
    f.ensureMap()
    var vs []string
    vs, ok = f.fmap[key]
    if !ok || len(vs) == 0 {
        return
    }
    return vs[0], true
}

// Values returns multiple values for a key and whether the key was actually present.
func (f *dynamicField) Values(key string) (values []string, ok bool) {
    f.ensureMap()
    values, ok = f.fmap[key]
    if !ok {
        return
    }
    return values, true
}

func main() {
    dec := json.NewDecoder(os.Stdin)
    doc := New{{ .Name }}()

    if err := dec.Decode(&doc); err != nil {
        log.Fatal(err)
    }

    fmt.Printf("%+v", doc)
}
```

## TODO

* [x] schema.xml -> dynamic fields
* [x] marshal dynamic fields, MarshalJSON
* [x] unmarshal dynamic fields, UnmarshalJSON
* [ ] tests
* [ ] test for potentially ambigue dynamic field names, `local_heading_facet_*` and `local_heading_*`
